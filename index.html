<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="JIoJYQLXUMHBZfXbnazdyv_v0mfXHpgskwwlfvZGooc" />








  <meta name="baidu-site-verification" content="0bPMZzrl7R" />













<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="黄济芃的博客">
<meta property="og:url" content="https://huangstomach.github.io/index.html">
<meta property="og:site_name" content="黄济芃的博客">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="黄济芃的博客">






  <link rel="canonical" href="https://huangstomach.github.io/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>黄济芃的博客</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">黄济芃的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <h1 class="site-subtitle" itemprop="description">这玩意能坚持写？</h1>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://huangstomach.github.io/2019/08/05/Git提交与修改/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HuangStomach">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄济芃的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/05/Git提交与修改/" itemprop="url">
                  Git提交与修改
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-05 10:27:14 / 修改时间：10:52:15" itemprop="dateCreated datePublished" datetime="2019-08-05T10:27:14+08:00">2019-08-05</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Git/" itemprop="url" rel="index"><span itemprop="name">Git</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>Git要求开发者在编写提交的时候，尽量要填写有用的信息；在工作中更甚，提交写的完善完备更能让问题追踪变得容易可控，不过可能会遇到不小心写错了提交内容的情况，这时候就一定要在推送之前想办法把错误的提交信息修正掉。</p>
</blockquote>
<h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><p>Git提交是一件非常简单的事情，对于我来说不过是先检查一下需要提交的文件，然后直接一个<code>git commmit</code>就结束了的工作，当敲下回车，就会出现熟悉的界面：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> post Git提交与修改</span><br><span class="line"></span><br><span class="line"># Please enter the commit message <span class="keyword">for</span> your <span class="keyword">changes</span>. Lines starting</span><br><span class="line"># with <span class="string">'#'</span> will <span class="keyword">be</span> ignored, <span class="built_in">and</span> <span class="keyword">an</span> <span class="built_in">empty</span> message aborts the commit.</span><br><span class="line">#</span><br><span class="line"># Date:      Mon Aug <span class="number">5</span> <span class="number">10</span>:<span class="number">17</span>:<span class="number">05</span> <span class="number">2019</span> +<span class="number">0800</span></span><br><span class="line">#</span><br><span class="line"># On branch master</span><br><span class="line"># Your branch <span class="keyword">is</span> ahead of <span class="string">'origin/master'</span> by <span class="number">1</span> commit.</span><br><span class="line">#   (use <span class="string">"git push"</span> <span class="keyword">to</span> publish your local commits)</span><br><span class="line">#</span><br><span class="line"># Changes <span class="keyword">to</span> <span class="keyword">be</span> committed:</span><br><span class="line">#       <span class="keyword">new</span> <span class="keyword">file</span>:   <span class="keyword">source</span>/_posts/Git提交与修改.md</span><br><span class="line">#</span><br></pre></td></tr></table></figure>
<p>其中第一行就是提交描述信息，也是最重要的地方；第六行是提交时间，第十二行开始则是本次提交修改的文件概览。</p>
<p>有的时候开发者比较自信或者非常熟练，直接使用<code>git commit -m &lt;message&gt;</code>来进行快速提交。其实commit中除了<code>-m --message</code>之外还可以快速设置一些其他的信息:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Commit message options</span><br><span class="line">    --author &lt;author&gt;             override author <span class="keyword">for</span> commit</span><br><span class="line">    --date &lt;date&gt;                 override date <span class="keyword">for</span> commit</span><br><span class="line">    -m, --message &lt;message&gt;       commit message</span><br><span class="line">    -c, --reedit-message &lt;commit&gt; reuse and edit message from specified commit</span><br><span class="line">    -C, --reuse-message &lt;commit&gt;  reuse message from specified commit</span><br><span class="line">    --reset-author                the commit is authored by me now (used with -C/-c/--amend)</span><br></pre></td></tr></table></figure>
<p>这边随便列举了几个，如我们可以快速设置作者、时间，甚至使用<code>--reset-author</code>来把某个提交的作者设置成自己，这个参数的说明很有意思，而且后面标注了，要伴随<code>-C/-c/--amend</code>使用，这是什么参数？</p>
<h2 id="修改提交"><a href="#修改提交" class="headerlink" title="修改提交"></a>修改提交</h2><p>我们使用<code>man</code>命令来查看一下说明，可以看到其实和：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --soft HEAD^</span><br><span class="line">$ <span class="comment">#... do something else to come up with the right tree ...</span></span><br><span class="line">$ git commit -c ORIG_HEAD</span><br></pre></td></tr></table></figure>
<p>是等价的，实际上是创建了一个新的提交而不是直接修改上一个提交，当我键入<code>git commit --amend</code>之后，就会出现熟悉的界面了，这时候就可以把错误的提交信息修正掉了。</p>
<p>同时也可以和其他快捷参数一起使用，比如说你不想看你之前提交信息写的究竟是什么，也可以直接使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend -m &lt;message&gt;</span><br></pre></td></tr></table></figure>
<p>来快速修改提交信息，同时也可以根据上述参数描述进行修改，比如修改时间：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend --date &lt;date&gt;</span><br></pre></td></tr></table></figure>
<p>不过这里需要注意的是这里的参数是特定的时间格式，可以尝试使用<code>date</code>，不过不能直接使用<code>date</code>命令，因为此处的参数是要求符合<code>RFC 2822</code>标准的，所以需要使用如下命令来查看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ date -R</span><br><span class="line">Mon, 05 Aug 2019 10:50:35 +0800</span><br></pre></td></tr></table></figure>
<p>然后再根据这个格式修改时间就可以完成修改commit提交时间的操作了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend --date=`Mon, 05 Aug 2019 10:50:35 +0800`</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://huangstomach.github.io/2019/04/08/拓扑排序与装修/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HuangStomach">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄济芃的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/08/拓扑排序与装修/" itemprop="url">
                  拓扑排序与装修
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-08 20:38:45 / 修改时间：21:04:28" itemprop="dateCreated datePublished" datetime="2019-04-08T20:38:45+08:00">2019-04-08</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>最近在搞装修，发现在装修的过程中，很容易无法区分各种节点的主次，这时候就想起了拓扑排序。</p>
</blockquote>
<h2 id="装修"><a href="#装修" class="headerlink" title="装修"></a>装修</h2><p>装修的过程中，一般都要经历很多的节点，比如：砌墙、刷漆、安装空调新风、吊顶、铺设地板瓷砖、水电等等。</p>
<p>大部分的功能其实是相互依赖的，比如你必须砌墙了才能刷漆；安装了新风空调才能吊顶；确定了电器才能打橱柜等等等等。这种繁琐的问题自己捋的时候经常混乱，有时候不得不就咨询施工方，总是怕自己耽误了进度。</p>
<p>这时候突然想到了算法中的调度问题。</p>
<h2 id="逆后序"><a href="#逆后序" class="headerlink" title="逆后序"></a>逆后序</h2><p>一般来说，数据结构（尤其是图）的遍历一般分为三种排列顺序。</p>
<ul>
<li>前序</li>
<li>后序</li>
<li>逆后序</li>
</ul>
<p>其中逆后序定义是：<em>在递归调用之后将顶点压入栈</em></p>
<p>也就是说，在节点没有被彻底搜索完之前是不会进入到栈中的，也就是说最先被加入栈的则是没有后续节点的节点，也就是最后的工序比如：<strong>进家具</strong>。</p>
<p>其中，这些步骤，也就是我们的节点，相互的依赖关系则将它们形成了一副<em>有向图</em>，这也是进行逆后序的关键。</p>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>拓扑排序有可能有很多种算法来实现，主要是为了将杂乱无章的调度问题规划为一个线性的有序排列，为我们解决各种各样的问题，比如装修。逆后序就是其中的一种简单算法。</p>
<p>逆后序实现起来非常简单，如定义一样，只需要在深度优先搜索中加入简单的一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line"><span class="keyword">private</span> Stack&lt;Integer&gt; reversePost;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示意</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Digraph G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    marked[v] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> w: G.adj(v)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!marked[w]) dfs(G, w);</span><br><span class="line">    &#125;</span><br><span class="line">    reversePost.push(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中再想获取拓扑排序的时候，只需要简单的进行出栈操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int v: reversePost) &#123;</span><br><span class="line">    System.out.println(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就可以非常简单直观的输出所需要的顺序，从而简化了调度任务。</p>
<p>我也就知道我得先赶紧买空调和新风了。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://huangstomach.github.io/2019/02/12/KMP与有限状态自动机/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HuangStomach">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄济芃的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/12/KMP与有限状态自动机/" itemprop="url">
                  KMP与有限状态自动机
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-02-12 20:48:12 / 修改时间：21:22:29" itemprop="dateCreated datePublished" datetime="2019-02-12T20:48:12+08:00">2019-02-12</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>最近在学习字符串查找算法时，遇到了KMP算法，其中关于这块的介绍较为晦涩，记录一下自己的理解</p>
</blockquote>
<h2 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h2><p>字符串查找是一个应用非常多的功能，无论什么语言都会拥有该功能相关的一些周边函数或者概念，比如SQL。</p>
<p>通常来说，普通开发日常使用的时候，最简单的算法也就是暴力查找：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> M = pat.length(); <span class="comment">// 需匹配的字符串</span></span><br><span class="line"><span class="keyword">int</span> N = txt.length(); <span class="comment">// 原文本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N - M; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> j</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (txt.charAt(i + j) != pat.charAt(j)) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j == M) <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>这也是非常好理解的一种算法，将原文本中的每个字符都和匹配串的第一个字符进行比较，如果不匹配就去匹配下一个，如果匹配，则继续在匹配字符串中继续查找，直到匹配到末尾则是为成功。</p>
<p>这个算法可以直接达到目的，但是其中仍然有一些可以优化的地方，比如在字符串<code>AABAABAAAA</code>中查找字符串<code>AABAAA</code>时，当匹配到<code>AABAAB</code>的<code>B</code>时，则必然出现匹配失败，按照暴力算法的代码，则会回退到第二个<code>A</code>再次进行匹配，然而很明显，我们知道实际上完全不需要进行这么多的回退，<strong>KMP</strong> 算法则是为了解决该问题而出现的。</p>
<h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p>KMP算法网上大多也有介绍，基本上都是基于<code>next[]</code>来判断需要进行多少个字符的回退。</p>
<p>在Sedgewick的《Algorithms》一书中则使用了一种不太一样的计算方法，使得回退无需依赖于原字符串，而是仅仅使用匹配字符串就可以进行回退字符个数的预计，这就要归功于<strong>有限状态自动机</strong></p>
<h2 id="有限状态自动机"><a href="#有限状态自动机" class="headerlink" title="有限状态自动机"></a>有限状态自动机</h2><p>概念非常简单，就是记录在有限状态下，每个状态可以迁移到的0个或多个状态。简单来说，就类似于一种固定好的有向图，当给入一个属于字母表中的字符的时候，都可以按照预先定义好的状态，按照方向转移到下一个状态中，对应KMP算法则意味着回退到什么地方。</p>
<p><img src="/2019/02/12/KMP与有限状态自动机/DFA.png" alt="DFA"></p>
<p>以图中为例，当匹配字符串为<code>ABABAC</code>时，有限状态机定义如下：</p>
<p>先暂定输入字母表为<code>ABC</code>三个字符</p>
<ul>
<li><p>当输入<code>A</code>的时候，<code>A</code>被匹配到，状态机会认为其可以进行到状态<code>1</code>，输入另外两个则无法进行匹配，则为<code>0</code></p>
</li>
<li><p>当再次输入<code>A</code>的时候，<code>B</code>则无法被匹配到，<code>A</code>字符的状态则被回滚到上个地方<code>1</code>，而输入<code>B</code>被匹配记录状态为<code>2</code></p>
</li>
<li><p>再次输入<code>A</code>则又可以匹配到，此时的<code>A</code>会被记录状态为<code>3</code>，另外两个字符则还是会进行回退</p>
</li>
<li><p>当再次输入<code>A</code>的时候，<code>B</code>则无法被匹配到，<code>A</code>字符的状态则被回滚到上个地方<code>1</code>，而输入<code>B</code>被匹配记录状态为<code>4</code></p>
</li>
<li><p>再次输入<code>A</code>则又可以匹配到，此时的<code>A</code>会被记录状态为<code>5</code>，另外两个字符则还是会进行回退</p>
</li>
<li><p>再次输入<code>A</code>和<code>B</code>的时候都无法被匹配到，<code>A</code>还是会回滚到<code>1</code>处，而<code>B</code>因为此时重启状态为<code>3</code>，则退回到<code>4</code>的位置</p>
</li>
</ul>
<p>其中重启状态是个比较有意思的概念，就是需要回退到的状态，由于需要右移和忽略最后一个匹配失败，回退状态会在<code>charAt(1)</code>到<code>charAt(j - 1)</code>之间，也就是上一个可以达到的状态。</p>
<p>这种基于有限状态自动机的方式无需进行查找字符串中的回退，减少了消耗，是一种高效的查找算法</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://huangstomach.github.io/2018/12/29/Vyssotsky与最小生成树/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HuangStomach">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄济芃的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/29/Vyssotsky与最小生成树/" itemprop="url">
                  Vyssotsky与最小生成树
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-29 21:43:13 / 修改时间：22:27:27" itemprop="dateCreated datePublished" datetime="2018-12-29T21:43:13+08:00">2018-12-29</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>开发一种不断使用环的性质的算法来计算最小生成树</p>
</blockquote>
<h2 id="环的性质"><a href="#环的性质" class="headerlink" title="环的性质"></a>环的性质</h2><p>当构建出一副无向图的最小生成树时可以发现，在无向图中任意将一条边加入最小生成树，都会构建出一个环；因为生成树(不一定最小)实际上会达到图中的所有点，再加入任何一条边都相当于多连接了一遍两个顶点，必然会产生环。</p>
<p>利用这个性质，可一每次都从新产生的环中删除权重最大的边，来不停构造最小生成树。</p>
<h2 id="Vyssotsky"><a href="#Vyssotsky" class="headerlink" title="Vyssotsky"></a>Vyssotsky</h2><p>首先可以先随便拟定一个生成树（不一定最小）:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">edges = <span class="keyword">new</span> Queue&lt;Edge&gt;();</span><br><span class="line">mst = <span class="keyword">new</span> EdgeWeightedGraph(G.V());</span><br><span class="line"><span class="keyword">boolean</span>[] marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line"><span class="keyword">for</span> (Edge e: G.edges()) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = e.either();</span><br><span class="line">    <span class="keyword">int</span> w = e.other(v);</span><br><span class="line">    <span class="keyword">if</span> (marked[v] &amp;&amp; marked[w]) &#123;</span><br><span class="line">        edges.enqueue(e);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    marked[v] = <span class="keyword">true</span>;</span><br><span class="line">    marked[w] = <span class="keyword">true</span>;</span><br><span class="line">    mst.addEdge(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>marked</code>来记录点是否已经被连接过，如果两个顶点均被连接过，则将该条边放入备选<code>edges</code>中，否则加入新图，也就是生成树中。</p>
<p>然后不停地将备选边中的边加入到生成树中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (edges.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    Edge e = edges.dequeue();</span><br><span class="line">    mst.addEdge(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时一定会产生环，使用深度优先算法对环进行检测，从而找到权重最大的边：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> skip)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Edge e: mst.adj(start)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(e.weight())) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> v = e.other(start);</span><br><span class="line">        <span class="keyword">if</span> (v == skip) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (v == end || dfs(v, end, start)) &#123;</span><br><span class="line">            max = Math.max(max, e.weight());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中寻找的时候要把前一条边的起点忽略掉，这里就没没有再使用<code>marked</code>数组了。</p>
<h2 id="删除边"><a href="#删除边" class="headerlink" title="删除边"></a>删除边</h2><p>然后就是要将权重最大的边删除掉，这里给的加权无向图<code>EdgeWeightedGraph</code>中没有提供删除边的API，也没有说需要自行扩展，这里就利用了<strong>所有权重均不相同</strong>的性质，将最大权重加入到集合中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (edges.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    Edge e = edges.dequeue();</span><br><span class="line">    max = e.weight();</span><br><span class="line">    mst.addEdge(e);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> v = e.either();</span><br><span class="line">    dfs(v, e.other(v), e.other(v));</span><br><span class="line">    set.add(max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样虽然是全部边都加入了新图中，但是在我们获取最小生成树的时候，如果遇到了边的权重在集合中，则进行跳过：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterable&lt;Edge&gt; <span class="title">edges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Queue&lt;Edge&gt; queue = <span class="keyword">new</span> Queue&lt;Edge&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Edge e: mst.edges()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(e.weight())) <span class="keyword">continue</span>;</span><br><span class="line">        queue.enqueue(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写了下测试，可以通过。整体代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VyssotskyMST</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Edge&gt; edges;</span><br><span class="line">    <span class="keyword">private</span> EdgeWeightedGraph mst;</span><br><span class="line">    <span class="keyword">private</span> HashSet set;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> max;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VyssotskyMST</span><span class="params">(EdgeWeightedGraph G)</span> </span>&#123;</span><br><span class="line">        edges = <span class="keyword">new</span> Queue&lt;Edge&gt;();</span><br><span class="line">        set = <span class="keyword">new</span> HashSet&lt;Double&gt;();</span><br><span class="line">        mst = <span class="keyword">new</span> EdgeWeightedGraph(G.V());</span><br><span class="line">        <span class="keyword">boolean</span>[] marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        <span class="keyword">for</span> (Edge e: G.edges()) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e.either();</span><br><span class="line">            <span class="keyword">int</span> w = e.other(v);</span><br><span class="line">            <span class="keyword">if</span> (marked[v] &amp;&amp; marked[w]) &#123;</span><br><span class="line">                edges.enqueue(e);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            marked[v] = <span class="keyword">true</span>;</span><br><span class="line">            marked[w] = <span class="keyword">true</span>;</span><br><span class="line">            mst.addEdge(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (edges.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Edge e = edges.dequeue();</span><br><span class="line">            max = e.weight();</span><br><span class="line">            mst.addEdge(e);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> v = e.either();</span><br><span class="line">            dfs(v, e.other(v), e.other(v));</span><br><span class="line">            set.add(max);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> skip)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Edge e: mst.adj(start)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(e.weight())) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> v = e.other(start);</span><br><span class="line">            <span class="keyword">if</span> (v == skip) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (v == end || dfs(v, end, start)) &#123;</span><br><span class="line">                max = Math.max(max, e.weight());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Edge&gt; <span class="title">edges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Queue&lt;Edge&gt; queue = <span class="keyword">new</span> Queue&lt;Edge&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Edge e: mst.edges()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(e.weight())) <span class="keyword">continue</span>;</span><br><span class="line">            queue.enqueue(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        In in = <span class="keyword">new</span> In(args[<span class="number">0</span>]);</span><br><span class="line">        EdgeWeightedGraph G = <span class="keyword">new</span> EdgeWeightedGraph(in);</span><br><span class="line">        VyssotskyMST mst = <span class="keyword">new</span> VyssotskyMST(G);</span><br><span class="line">        <span class="keyword">for</span> (Edge e: mst.edges()) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自己描述一边算法也是对思路的一个整理，现在发现其实在第一次遍历中就可以开始环的判断了，没有必要收集起来再做遍历。</p>
<p>目前自己都觉得性能不太好，之后有机会还是会进行优化。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://huangstomach.github.io/2018/11/02/ECMAScript与误区/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HuangStomach">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄济芃的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/02/ECMAScript与误区/" itemprop="url">
                  ECMAScript与误区
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-02 22:56:21" itemprop="dateCreated datePublished" datetime="2018-11-02T22:56:21+08:00">2018-11-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-11-05 22:51:08" itemprop="dateModified" datetime="2018-11-05T22:51:08+08:00">2018-11-05</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>最近在和一些年轻的js开发者的交流中，发现大家对于一些ECMAScript标准仍然有一些误区</p>
</blockquote>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>在一些网络文章中，经常可以看到对于<code>const</code>的一些描述，大多数都是说明: <em>一旦声明则不可进行修改的常量</em></p>
<p>我就经常会用这个来分辨一些只是浅尝辄止的开发者，也是我面试中的一个非常小的问题:</p>
<p><em>当我声明了一个常量数组后，我还可以向内推送元素么？</em></p>
<p>可惜很大一部分的同学都会回答我不能，因为声明了就不能改变。实际上，这里不能改变的不是值，而是指向的内存地址。</p>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>往往一些简单的特性所隐藏的功能则经常带来一些问题，我认识的一些开发者极其热衷于使用箭头函数，哪怕是在第三方的库中。</p>
<p>他们简单的认为箭头函数仅仅是简写了<code>function</code>关键字，然而当他们在一些内部函数或回调函数中尝试使用箭头函数的时候却发现，再也取不到相应<code>this</code>了。</p>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>在<code>Proimse</code>普及之前，我们的代码经常是这样的:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a.do(<span class="string">'sth'</span>, ra =&gt; &#123;</span><br><span class="line">    b.do(<span class="string">'sth'</span>, rb =&gt; &#123;</span><br><span class="line">        c.do(<span class="string">'sth'</span>, rc =&gt; &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>拜异步特性所赐，我们的代码经常写的像锥子。</p>
<p>这时候<code>Promise</code>横空出世，然而周围的开发者90%居然会这么写:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a.then(<span class="function"><span class="params">ra</span> =&gt;</span> &#123;</span><br><span class="line">    b.then(<span class="function"><span class="params">rb</span> =&gt;</span> &#123;</span><br><span class="line">        c.then(<span class="function"><span class="params">rc</span> =&gt;</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>说实话，写的时候就没有疑问这和之前有什么区别么？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">.then(<span class="function"><span class="params">ra</span> =&gt;</span> b)</span><br><span class="line">.then(<span class="function"><span class="params">rb</span> =&gt;</span> c)</span><br><span class="line">.then(<span class="function"><span class="params">rc</span> =&gt;</span> &#123; ... &#125;)</span><br></pre></td></tr></table></figure>
<p>解决回调嵌套地狱，才是<code>Promise</code>褒受欢迎的原因之一。</p>
<h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2><p>曾经有个同事向我强力推荐<code>koa</code>, 当时公司内部用<code>express</code>比较多，我就问他，为什么要用<code>koa</code>呢？</p>
<p>回答居然是<code>koa</code>能用<code>async</code>……</p>
<p><code>async</code>并不是一个指向性那么强的特性，实际上很多地方都能简单的用到，比如<code>express</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'*'</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">    <span class="comment">// do sth</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>还有的朋友问过我，我都使用了这个特性了，为什么代码还是不像我想象中的运行呢？</p>
<p>实际上<code>async</code>只是一个语法糖，只是让你用同步代码的编写方式来<strong>写</strong>异步代码而已，<code>ES6</code>中其他大部分的特性同理。</p>
<h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><p><code>React</code>充分应用着<code>class</code>的特性，虽然我没有仔细阅读过源码去看具体的实现是否和<code>ES6</code>中的完全相符，我经常看到这样的代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> <span class="title">extend</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> (props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上哪怕你不声明，<code>class</code>也会隐式的生成并调用构造函数。</p>
<h2 id="还是Class"><a href="#还是Class" class="headerlink" title="还是Class"></a>还是Class</h2><p>这仍然是原型链的一种实现，不要想太多了。</p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>我觉得最有用的特性现在看来还是尾递归优化……</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://huangstomach.github.io/2018/10/07/Swoole与跨域/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HuangStomach">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄济芃的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/07/Swoole与跨域/" itemprop="url">
                  Swoole与跨域
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-10-07 19:29:55 / 修改时间：20:17:34" itemprop="dateCreated datePublished" datetime="2018-10-07T19:29:55+08:00">2018-10-07</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/PHP/" itemprop="url" rel="index"><span itemprop="name">PHP</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Swoole"><a href="#Swoole" class="headerlink" title="Swoole"></a>Swoole</h2><p><a href="https://wiki.swoole.com/" target="_blank" rel="noopener">Swoole</a>是我经常在使用的PHP的协程高性能网络通信引擎，非常好用，为PHP又提供了许多出乎意料的使用拓展，如携程异步等。并且是由<code>C/C++</code>语言编写，作为一个扩展安装使用非常的简单。</p>
<p>我在工作之余尝试将<code>Swoole</code>和公司框架<code>Gini</code>进行共同使用，效果不错，可见两者都符合低耦合的设计理念。简单的增加了一个<code>index.php</code>来作为程序的主入口，就非常简单的使用起了大部分功能。</p>
<p>例如在接受<code>http</code>请求方面:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span><span class="params">($req, $res)</span> </span>&#123;</span><br><span class="line">    $header = $req-&gt;header;</span><br><span class="line">    $_SERVER = array_merge($_SERVER, $req-&gt;server);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 传入res对象使后续可以对res对象进行操作</span></span><br><span class="line">    $uri = trim($_SERVER[<span class="string">'request_uri'</span>], <span class="string">'/'</span>);</span><br><span class="line">    $result = \Gini\CGI::request($uri, [</span><br><span class="line">        <span class="string">'header'</span> =&gt; $header,</span><br><span class="line">        <span class="string">'get'</span> =&gt; $req-&gt;get,</span><br><span class="line">        <span class="string">'post'</span> =&gt; $req-&gt;post,</span><br><span class="line">        <span class="string">'files'</span> =&gt; [], <span class="comment">// 暂且先不考虑file</span></span><br><span class="line">        <span class="string">'route'</span> =&gt; $uri,</span><br><span class="line">        <span class="string">'method'</span> =&gt; $_SERVER[<span class="string">'request_method'</span>],</span><br><span class="line">        <span class="string">'swoole'</span> =&gt; <span class="keyword">$this</span>-&gt;server, <span class="comment">// swoole_server 对象</span></span><br><span class="line">        <span class="string">'raw'</span> =&gt; $req-&gt;rawContent(),</span><br><span class="line">    ])-&gt;execute();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止php://output过多挤压supervisor.log</span></span><br><span class="line">    ob_start();</span><br><span class="line">    $result-&gt;output();</span><br><span class="line">    ob_end_clean();</span><br><span class="line"></span><br><span class="line">    $res-&gt;status(http_response_code());</span><br><span class="line">    $res-&gt;end(J($result-&gt;content()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就非常简单的可以将<code>Swoole</code>传递过来的请求，分发到<code>Gini</code>框架的路由当中去，再做各自的逻辑处理。</p>
<p>但是当我部署到生产环境的时候，就出现了一件比较尴尬的事情，跨域警告了。</p>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>什么是跨域呢，前端可能接触的比较多，这并不是服务器做出的限制，而是浏览器的安全策略。</p>
<p>浏览器为了防止不同域之间发生不安全的数据交互或者攻击，会默认阻止这种行为。但是有些时候我们的应用的确是部署在不同的域下，这时候我们就要了解跨域的原理了。</p>
<p>当我们打开调试工具的时候，会发现在跨域请求之前，我们会看到一个类似这样的请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Request URL: http://path.to/api</span><br><span class="line">Request Method: OPTIONS</span><br></pre></td></tr></table></figure>
<p>但是没有任何的消息体进行返回，然后就报错了，不能跨域。</p>
<p>实际上，浏览器在阻止跨域请求之前，会向目标服务器发送一个这样的请求，来询问服务器：什么样子的请求可以跨域啊？</p>
<p>然后服务器就会将自己的配置告诉浏览器，来方便做后续的判断。这也就是网上大部分的解决方案有效的原因了，比如<code>nginx</code>:</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">add_header</span> Access-Control-Allow-Origin http://path.to;</span><br><span class="line"><span class="attribute">add_header</span> Access-Control-Allow-Credentials <span class="literal">true</span>;</span><br><span class="line"><span class="attribute">add_header</span> Access-Control-Allow-Headers X-Requested-With;</span><br><span class="line"><span class="attribute">add_header</span> Access-Control-Allow-Methods GET,POST,OPTIONS;</span><br></pre></td></tr></table></figure>
<p>实际上就是告诉了浏览器，我允许跨域的<code>Origin</code>, <code>Headers</code>, <code>Methods</code>等，如果请求符合，则就可以进行正常的跨域请求。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>这个在传统的<code>PHP</code>开发中很好解决，我们一般会在Web服务器如<code>nginx</code>或<code>apache</code>中进行修改解决，但是<code>Swoole</code>实际上自己充当了一部分<code>Http</code>服务器的角色，所以我们需要稍微做一下改动。</p>
<p>上面说到了，具体能否跨域，主要取决于<code>OPTIONS</code>请求所返回的信息，所以我们可以在这里加以拦截:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span><span class="params">($req, $res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ($req-&gt;server[<span class="string">'request_method'</span>] == <span class="string">'OPTIONS'</span>) &#123;</span><br><span class="line">        $res-&gt;status(http_response_code());</span><br><span class="line">        $res-&gt;end();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以终止后面的路由解析行为，防止后面的逻辑再做其他的处理，然后像nginx配置的那样，我们需要加上我们希望返回的头内容：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span><span class="params">($req, $res)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 跨域OPTIONS返回</span></span><br><span class="line">    $res-&gt;header(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'*'</span>);</span><br><span class="line">    $res-&gt;header(<span class="string">'Access-Control-Allow-Methods'</span>, <span class="string">'GET, POST, DELETE, PUT, PATCH, OPTIONS'</span>);</span><br><span class="line">    $res-&gt;header(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'Authorization, User-Agent, Keep-Alive, Content-Type, X-Requested-With'</span>);</span><br><span class="line">    <span class="keyword">if</span> ($req-&gt;server[<span class="string">'request_method'</span>] == <span class="string">'OPTIONS'</span>) &#123;</span><br><span class="line">        $res-&gt;status(http_response_code());</span><br><span class="line">        $res-&gt;end();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里我简单的加入了几个常用的<code>Methods</code>和<code>Headers</code>，这样实际上我们<code>Swoole</code>在接收到浏览器的跨域侦测时，就能返回正常的信息并继续跨域请求了。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://huangstomach.github.io/2018/08/25/按需加载与代码分割/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HuangStomach">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄济芃的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/25/按需加载与代码分割/" itemprop="url">
                  按需加载与代码分割
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-08-25 13:31:19 / 修改时间：14:34:35" itemprop="dateCreated datePublished" datetime="2018-08-25T13:31:19+08:00">2018-08-25</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>之前在社交平台上随手给一个朋友回答了个小问题，发现按需加载和代码分割的概念非常容易混淆，也无法对前端应用的性能进行实质的提升</p>
</blockquote>
<h2 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h2><p>按需加载其实说起来非常高大上但是其实很简单，<a href="http://element.eleme.io/#/zh-CN/component/quickstart" target="_blank" rel="noopener">element官网</a>上就有简单的说明</p>
<p>可以看到其使用了一个很简单的特性，ES6的import特性，可以简单的为我们引入需要的组件等:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Button, Select &#125; <span class="keyword">from</span> <span class="string">'element-ui'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span>;</span><br><span class="line"></span><br><span class="line">Vue.component(Button.name, Button);</span><br><span class="line">Vue.component(Select.name, Select);</span><br><span class="line"><span class="comment">/* 或写为</span></span><br><span class="line"><span class="comment"> * Vue.use(Button)</span></span><br><span class="line"><span class="comment"> * Vue.use(Select)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们可以看到，其中在引入<code>element-ui</code>的时候，仅仅引入了我们所需要的两个组件。</p>
<p><code>element-ui</code>为我们提供了许多丰富的组件，但是可能在日常开发中我们只能用到一小部分，那么这个特性就会很好的帮助我们进行第三方组件引入的最小化了。</p>
<p>不过我遇到的这位朋友使用的方法让我意想不到，给我描述的情况是，他的确只引入了需要的组件，但是整个前端应用还是非常的庞大，导致首屏加载仍然非常缓慢。</p>
<p>仔细询问发现，他只是单纯使用了按需加载的属性，将所有需要用到的组件都像实例那样进行了引入。实际上，如果仅仅单纯的地使用这个特性，在使用了80%以上组件的情况下，结果和整体引入ui库也并无区别。</p>
<h2 id="代码分割"><a href="#代码分割" class="headerlink" title="代码分割"></a>代码分割</h2><p>在我看来，按需加载实际上和代码分割的辅助功能是相辅相成的，在没有代码分割之下，所有的按需加载实际上仍然会将所有的第三方库全部压缩到一个工程文件中，导致该文件下载缓慢，运行缓慢。</p>
<p>实际上这一概念已经存在很久了无论是:</p>
<p><a href="https://router.vuejs.org/zh/guide/advanced/lazy-loading.html" target="_blank" rel="noopener">vue-router 路由懒加载</a></p>
<p>亦或是</p>
<p><a href="https://reactjs.org/docs/code-splitting.html" target="_blank" rel="noopener">react code-splitting</a></p>
<p>中都有提到，当然他们主要也是借用的<code>webpack</code>的一项特性<a href="https://webpack.js.org/guides/code-splitting/" target="_blank" rel="noopener">code-splitting</a></p>
<p>我们在这篇介绍中可以看到，webpack为我们提供了一种动态<code>import</code>的功能：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "lodash" */</span> <span class="string">'lodash'</span>);</span><br></pre></td></tr></table></figure>
<p>就像文章中所说的，这种写法会帮我们将引入的文件单独进行一个文件的分割打包，这样我们庞大的应用就会被我们精心地拆成一个个单独的js文件，互不影响，异步加载，极大地节省了我们的首屏加载时间。</p>
<p>这里和<strong>按需加载</strong>是相辅相成的，我们可以把我们需要使用的第三方组件分布在我们的各个小组件中，并让这些组件进行代码分割，从而达到最大化优化效果的目的。</p>
<p>同样我们可以看到这个语法中有一行注释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/* webpackChunkName: &quot;lodash&quot; */</span><br></pre></td></tr></table></figure>
<p><code>webpack</code>会根据我们注释中所写的<code>ChunkName</code>也就是我们为这个包起得名字，将相同名字的包打入到一个文件中，这样哪怕我们希望打入一个包的组件之间没有继承关系，也能在这里进行处理。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>代码分割和按需加载已经很大程度上为我们进行了前端优化了，我们还需要优化什么呢？</p>
<p>我的一些同事在代码分割上做的不是很理智，这里我们先介绍一个<code>webpack</code>推荐的分析辅助插件<code>webpack-bundle-analyzer</code>。</p>
<p>个人觉得这是一款非常好用的插件，只要进行简单的配置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> BundleAnalyzerPlugin(&#123;</span><br><span class="line">      analyzerMode: <span class="string">'server'</span>,</span><br><span class="line">      analyzerHost: <span class="string">'0.0.0.0'</span>,</span><br><span class="line">      analyzerPort: <span class="number">8181</span>,</span><br><span class="line">      reportFilename: <span class="string">'report.html'</span>,</span><br><span class="line">      defaultSizes: <span class="string">'parsed'</span>,</span><br><span class="line">      openAnalyzer: <span class="literal">true</span>,</span><br><span class="line">      generateStatsFile: <span class="literal">false</span>,</span><br><span class="line">      statsFilename: <span class="string">'stats.json'</span>,</span><br><span class="line">      statsOptions: <span class="literal">null</span>,</span><br><span class="line">      logLevel: <span class="string">'info'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置项我这边不再赘述了，运行<code>NODE_ENV=production ANALYZ=true npm_config_report=true npm run build</code>后则会为我们生成一个直观的build报告：</p>
<p><img src="/2018/08/25/按需加载与代码分割/1535175896358.jpg" alt="分析结果"></p>
<p>我们可以看到，每一个文件都被分割成了和自身大小比例相等的块，抛去这些最大的引入，我们可以看到右下角有一些几乎看不清的小引入，这些都是同事开发的功能组件，非常的小。</p>
<p>根据这个分析，我们可以得到目前占用体积最大的组件是哪几个，如果过多的占用了我们的加载时间，则应该进行继续分割优化。</p>
<p>但是如果我们的组件非常的小，如右下方的组件，不足1KB，个人觉得就不用进行拆分了，和其父组件在一起就可以，否则这种细碎组件拆分过多，加载性能上没有太多提升反而加大了http请求的压力。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://huangstomach.github.io/2018/07/28/栈与尾递归优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HuangStomach">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄济芃的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/28/栈与尾递归优化/" itemprop="url">
                  栈与尾递归优化
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-07-28 22:02:39" itemprop="dateCreated datePublished" datetime="2018-07-28T22:02:39+08:00">2018-07-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-08-03 21:15:46" itemprop="dateModified" datetime="2018-08-03T21:15:46+08:00">2018-08-03</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>JavaScript的ES2015标准已经被普及了很久了，众多的前后端应用也已经争先恐后地支持了这一标准，其中有一条也是最后一条很有意思，叫做<a href="https://babeljs.io/docs/en/learn/#tail-calls" target="_blank" rel="noopener">尾递归优化</a></p>
</blockquote>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>不得不先说一下栈</p>
<p>栈是一个比较基础的数据结构，大家也广为熟悉。不过可能使用起来不会被感觉到。</p>
<p>栈可以被比喻为学生时代的判卷，做得快的同学（或者交白卷的同学）的卷子往往会最先放在讲台上，然后后面交卷的同学卷子会盖在之前同学的卷子上，最后做的慢的同学（或者仍然是交白卷的同学）的卷子会在最上面，这种有序堆叠卷子的行为被称为<strong>入栈</strong></p>
<p>大家交完卷子的时候，老师会把卷子都抱走然后挨个判卷，最后交的卷子会被最先判到，按照顺序一张一张判完，这种行为叫做<strong>出栈</strong></p>
<p><br>当然也有老师边交卷边判卷的，这也是被栈允许的，并不是一定要全部入栈后才能出栈，但是仍然在老师拿卷子的那个时间点，拿到的是最后交的卷子。</p>
<p>这种顺序被我们称为<strong>先入后出</strong>或者<strong>后入先出</strong>……what ever……</p>
<p>Javascript中实际上也是存在着很多栈的调用的，比如常见的数组操作，借用<a href="https://developer.mozilla.org" target="_blank" rel="noopener">MDN</a>的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> animals = [<span class="string">'pigs'</span>, <span class="string">'goats'</span>, <span class="string">'sheep'</span>];</span><br><span class="line"></span><br><span class="line">animals.push(<span class="string">'cows'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(animals);</span><br><span class="line"><span class="comment">// 输出 ["pigs", "goats", "sheep", "cows"]</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到利用数组的<code>push</code>方法，我们将<code>cows</code>加入到了数组的末尾，这就是<strong>入栈</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> animals = [<span class="string">'pigs'</span>, <span class="string">'goats'</span>, <span class="string">'sheep'</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(animals());</span><br><span class="line"><span class="comment">// 输出 "sheep"</span></span><br><span class="line"><span class="built_in">console</span>.log(animals);</span><br><span class="line"><span class="comment">// 输出 ["pigs', 'goats"]</span></span><br></pre></td></tr></table></figure>
<p><code>pop</code>方法则为我们弹出了数组最后一个元素<code>sheep</code>，这就是<strong>出栈</strong></p>
<h2 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h2><p>为什么要介绍栈</p>
<p>我们在编写代码的时候，做最多的事情很可能就是调用一个又一个的函数、方法来打成我们的目的，这里实际上就是在不停地使用栈的概念：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> end = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'end'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> output = <span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> start = <span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'my name is'</span>);</span><br><span class="line">  output(name);</span><br><span class="line">  end();</span><br><span class="line">&#125;;</span><br><span class="line">start(<span class="string">'huangStomach'</span>);</span><br></pre></td></tr></table></figure>
<p>上述代码中，我们先调用了<code>start</code>函数，并在内部调用了<code>output</code>函数和<code>end</code>函数。当我们在调用<code>start</code>函数的时候，系统会为我们分配一块内存，存放我们调用的函数和它的参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="string">'start'</span>, &#123; <span class="attr">name</span>: <span class="string">'huangStomach'</span> &#125;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>当然这么写只是打个比方，它会被计算机放入到内存块中。然后，我们调用了<code>output</code>函数，同样，计算机也会分配一块内存：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="string">'output'</span>, &#123; <span class="attr">name</span>: <span class="string">'huangStomach'</span> &#125;],</span><br><span class="line">  [<span class="string">'start'</span>, &#123; <span class="attr">name</span>: <span class="string">'huangStomach'</span> &#125;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>它会被放在第一个内存块上面，形成一个<strong>栈</strong>。这时候我们打印了<code>name</code>，这个函数也被执行完成并弹出栈。接下来我们会执行第二个函数<code>end</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="string">'end'</span>],</span><br><span class="line">  [<span class="string">'start'</span>, &#123; <span class="attr">name</span>: <span class="string">'huangStomach'</span> &#125;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>它会打印<code>end</code>并完成自己的使命然后被弹出，这时候栈内只剩下一个元素：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="string">'start'</span>, &#123; <span class="attr">name</span>: <span class="string">'huangStomach'</span> &#125;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>然后我们的<code>start</code>方法也彻底的完成了使命，栈也被清空了。</p>
<h2 id="递归调用栈"><a href="#递归调用栈" class="headerlink" title="递归调用栈"></a>递归调用栈</h2><p>这和<strong>尾递归优化</strong>又有什么关系呢</p>
<p>比如我们可能有这样一个函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> factorial = (n, acc = <span class="number">1</span>) &#123;</span><br><span class="line"><span class="meta">    "use strict"</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> acc;</span><br><span class="line">    <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * acc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数是用来求阶乘的，我们可以看到在函数的末尾我们又调用了自身，这被称为一个递归调用函数。</p>
<p>有时候我们不会使用遍历而是使用递归，可能是习惯问题可能是为了代码更加优美，但实际上两种方法都能为我们解决同样的问题。</p>
<p>当我们使用递归的时候，可以看到我们在函数内部不停的调用函数，这就会形成<strong>栈</strong>，当我们传入的参数是<code>10</code>可能还可以非常快的计算出来，但是如果我们传入<code>100000</code>，则会报错<code>Maximum call stack size exceeded</code>也就是<code>stackoverflow</code>。</p>
<blockquote>
<p>当你冥思苦想，不断地为BUG唏嘘不已的时候，路过的扫地大妈会拍拍你的肩膀，告诉你：栈溢出了</p>
</blockquote>
<p>为什么会这样呢？因为函数调用栈的原因，过多的递归调用则会使栈不停地堆叠，直到超出系统的安全限制，我们不得不修改我们的代码，或者干脆切换到遍历。</p>
<p>但是在ES2015中，我们拥有了<strong>尾递归优化</strong>，当我们处于ES2015环境并开启了严格模式后，<strong>尾递归优化</strong>就启动了。</p>
<p>当递归函数的末尾<strong>仅有</strong>对自身函数的调用的时候，系统则会进行检测，发现可以对之前的<strong>栈</strong>进行复用，我们不用再不停地进行入栈操作，递归也真正有了用武之地。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://huangstomach.github.io/2018/07/21/侧边栏与屏幕适应/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HuangStomach">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄济芃的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/21/侧边栏与屏幕适应/" itemprop="url">
                  侧边栏与高度适应
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-07-21 10:11:03 / 修改时间：10:44:35" itemprop="dateCreated datePublished" datetime="2018-07-21T10:11:03+08:00">2018-07-21</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/CSS/" itemprop="url" rel="index"><span itemprop="name">CSS</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>在目前的大部分设计中，管理系统仍然不可忽视的一项重要功能就是侧边功能栏，然而在侧边功能栏上的开发，也绕过了许多的弯路</p>
</blockquote>
<h2 id="js侧边栏"><a href="#js侧边栏" class="headerlink" title="js侧边栏"></a>js侧边栏</h2><p>在我新手时期，也写过许多的侧边栏，侧边栏的要求很简单，和屏幕高度保持一致，并且功能项能在内部进行滚动，当时的我也是煞费苦心，为了能够准确地自适应，不得不用js去进行实现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">window</span>).resize(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sidebar = $(<span class="string">'#dashboard-sidebar'</span>);</span><br><span class="line">    sidebar.css(<span class="string">'height'</span>, <span class="string">'auto'</span>);</span><br><span class="line">    <span class="keyword">let</span> h = <span class="built_in">Math</span>.max(sidebar.outerHeight(), $(<span class="built_in">window</span>).height() - $(<span class="string">'#header'</span>).height());</span><br><span class="line">    sidebar.css(<span class="string">'height'</span>, h);</span><br><span class="line">&#125;).resize();</span><br></pre></td></tr></table></figure>
<p>可以说是非常的愚蠢了，每次都要在窗口变动的时候重新计算，会有视觉上的延误。</p>
<p>并且在首屏加载完成之前，还要忍受一个不正常的侧边栏等待渲染。</p>
<h2 id="绝对定位侧边栏"><a href="#绝对定位侧边栏" class="headerlink" title="绝对定位侧边栏"></a>绝对定位侧边栏</h2><p>在后续的开发中，觉得js实现侧边栏实在是太过愚蠢，不停地寻找解决方案的时候，发现实际上绝对定位是可以为我们解决问题的。</p>
<p>给侧边栏定好宽度，然后进行绝对定位，css会自动帮我们将高度和屏幕自适应，在很长一段时间内为我解决了问题。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">position</span>: <span class="selector-tag">fixed</span>;</span><br><span class="line"><span class="selector-tag">top</span>: 0;</span><br><span class="line"><span class="selector-tag">bottom</span>: 0;</span><br><span class="line"><span class="selector-tag">left</span>: 0;</span><br><span class="line"><span class="selector-tag">background-color</span>: <span class="selector-id">#444F61</span>;</span><br><span class="line"><span class="selector-tag">overflow-y</span>: <span class="selector-tag">auto</span>;</span><br></pre></td></tr></table></figure>
<p>很简单就完成了一个自适应的侧边栏，唯一的缺点就是因为使用了绝对定位，其他的元素得注意是否要纷纷绕道。</p>
<h2 id="现在的侧边栏"><a href="#现在的侧边栏" class="headerlink" title="现在的侧边栏"></a>现在的侧边栏</h2><p>后来由于绝对定位也是为我带来了一定程度上的困扰，一旦我修改侧边栏，其他元素也要纷纷跟着移动，每次修改起来也是令人很头疼，所以又开始研究其他的解决方案。</p>
<p>后来在使用<code>bootstrap</code>的时候，也沿用了它所使用的一个css属性值 <code>vh</code>。</p>
<p>很担心兼容性的我去MDN上进行了一下兼容性的查询，IE9就已经支持了。另外如果侧边栏之上还有顶部导航栏，仍然可以使用计算属性：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">height</span>: 100<span class="selector-tag">vh</span>;</span><br><span class="line"><span class="selector-tag">height</span>: <span class="selector-tag">calc</span>(100<span class="selector-tag">vh</span> <span class="selector-tag">-</span> 60<span class="selector-tag">px</span>);</span><br></pre></td></tr></table></figure>
<p>除了<code>vh</code>以外，也有很多类似的属性值如：<code>vw</code>、 <code>vmin</code> 和 <code>vmax</code>，都是进行自适应开发不错的选择。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://huangstomach.github.io/2018/07/09/静态文件与上传/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HuangStomach">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄济芃的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/09/静态文件与上传/" itemprop="url">
                  静态文件与上传
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-07-09 23:30:12" itemprop="dateCreated datePublished" datetime="2018-07-09T23:30:12+08:00">2018-07-09</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-08-18 11:32:06" itemprop="dateModified" datetime="2018-08-18T11:32:06+08:00">2018-08-18</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/PHP/" itemprop="url" rel="index"><span itemprop="name">PHP</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>在日常的后端开发中， 不可避免的就是要处理各种文件上传的需要， 随之而来的就是各种下载的需求， 我遇到的大部分开发者都会考虑到在上传的时候做简单的文件校验（有的也没有做）， 然而在文件下载的问题上， 则采用依赖于web服务器的静态文件传输， 经常造成很多的麻烦。</p>
</blockquote>
<h2 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h2><p>大部分开发者实际上在上传的时候都会对文件进行校验， 并且为了安全性考虑甚至会将文件更换名称。但是更换名称后简单的依赖于web服务器进行下载则会让用户拥有一种我的文件被篡改过的感觉（文件名发生了变化）。</p>
<p>依赖于web服务器的文件上传，则可以认为是相对依赖于浏览器的url的一种操作，一旦我们将web应用部署在二级目录下，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://origin/path/</span><br></pre></td></tr></table></figure>
<p>则很容易出现存储问题，比如我们存储的目录很可能因为这个原因需要多嵌套一层<code>path</code>目录</p>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>下载遇到的问题同理，最经常遇到的则是静态文件仅仅通过web服务器来做下载，不方便做权限管理，并且容易发生盗用资源的现象，其他的web应用用着你的资源，但是却耗费着你的带宽。</p>
<p>另一个则和上传的问题一样，下载的时候也避免不了遇到二级目录的问题，这时候web服务器很容易就带着二级目录去做寻找。</p>
<p>并且在资源进行删除的时候，其相关的静态文件如果没有进行处理也不好做清理，容易造成垃圾文件堆叠。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>我个人在这方面也是有吃过很多的亏，上面的问题全部都碰到过，最后决定使用各种编程语言中读取文件的api来进行解决:</p>
<ul>
<li>文件名更换</li>
<li>二级目录的问题</li>
<li>权限</li>
<li>下载</li>
</ul>
<p>其中文件名更换非常的简单，我习惯于在文件进行存储时，对其旧的文件名进行持久化存储，以PHP为例:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DATA_DIR 为web应用根目录的相对路径常量</span></span><br><span class="line"></span><br><span class="line">$uniqid = uniqid();</span><br><span class="line">$path = DATA_DIR . <span class="string">"/attached/&#123;$uniqid&#125;"</span>;</span><br><span class="line">    </span><br><span class="line">$ext = pathinfo($file[<span class="string">'name'</span>], PATHINFO_EXTENSION);</span><br><span class="line">$name = date(<span class="string">"YmdHis"</span>) . <span class="string">'_'</span> . rand(<span class="number">10000</span>, <span class="number">99999</span>) . <span class="string">'.'</span> . $ext;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (is_dir($path) &amp;&amp; is_uploaded_file($file[<span class="string">'tmp_name'</span>])</span><br><span class="line">&amp;&amp; move_uploaded_file($file[<span class="string">'tmp_name'</span>], <span class="string">"&#123;$path&#125;/&#123;$name&#125;"</span>)) &#123;</span><br><span class="line">    $old = $file[<span class="string">'name'</span>];</span><br><span class="line">    $dir = $path;</span><br><span class="line">    $path = <span class="string">"&#123;$path&#125;/&#123;$name&#125;"</span>;</span><br><span class="line">    $mime = $file[<span class="string">'type'</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以获得文件相关的四个变量，其中<code>$old</code>则为我们解决了文件名更换的问题，我们会将用户文件的文件名进行存储，而在我们本地则使用了<code>$name</code>来重命名保证安全文件</p>
<p>同时，二级目录问题也得到了解决，这里使用的是我们自定义的目录<code>$path</code>，不会受到部署的影响。</p>
<p>在下载的时候，我们也可以依赖于编程语言提供的api：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// APP_PATH 为web应用根目录的绝对路径常量</span></span><br><span class="line"></span><br><span class="line">$article; <span class="comment">// 假设我们的数据库映射对象是一篇文章</span></span><br><span class="line"><span class="keyword">if</span> (!$article-&gt;id) <span class="keyword">$this</span>-&gt;redirect(<span class="string">'error/404'</span>);</span><br><span class="line">$fullpath = APP_PATH . <span class="string">'/'</span> . $article-&gt;path;</span><br><span class="line">    </span><br><span class="line">header(<span class="string">"Content-Type: &#123;$article-&gt;mime&#125;"</span>);</span><br><span class="line">header(<span class="string">'Accept-Ranges: bytes'</span>);</span><br><span class="line">header(<span class="string">'Accept-Length:'</span> . filesize($fullpath));</span><br><span class="line">header(<span class="string">"Content-Disposition: attachment; filename=\"&#123;$article-&gt;old&#125;\""</span>);</span><br><span class="line">ob_clean();</span><br><span class="line"><span class="keyword">echo</span> file_get_contents($fullpath);</span><br><span class="line"><span class="keyword">exit</span>;</span><br></pre></td></tr></table></figure>
<p>这里由于是编程语言的实现，那么我们依赖于权限的问题也得到了解决，如第5行中代码返回<code>404</code>错误一样，我们也可以进行逻辑判断并返回<code>401</code>错误</p>
<p>并且同时，这里的下载也会从我们的数据库里面寻找文件，不用再被web服务器的二级目录所困扰，并且如果更加深入一下，额外的代码也可以降低我们的资源被盗用的风险。</p>
<p>以下是node的http框架<code>koa</code>的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>)()</span><br><span class="line"><span class="keyword">const</span> send = <span class="built_in">require</span>(<span class="string">'koa-send'</span>);</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/image'</span>, <span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> mongo = <span class="keyword">new</span> Database()</span><br><span class="line">  <span class="keyword">const</span> db = <span class="keyword">await</span> mongo.init()</span><br><span class="line">  <span class="keyword">let</span> platform = <span class="keyword">await</span> db.collection(<span class="string">'platform'</span>).findOne(&#123; <span class="string">"_id"</span>: <span class="string">"10010"</span> &#125;)</span><br><span class="line">  <span class="keyword">if</span> (platform) &#123;</span><br><span class="line">    ctx.attachment(platform.fileName);</span><br><span class="line">    <span class="keyword">await</span> send(ctx, platform.fileName, &#123; <span class="attr">root</span>: <span class="string">`<span class="subst">$&#123;__dirname&#125;</span>/../<span class="subst">$&#123;platform.filePath&#125;</span>`</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    ctx.body = &#123;</span><br><span class="line">      data: &#123;&#125;,</span><br><span class="line">      code: <span class="number">400</span>,</span><br><span class="line">      message: <span class="string">'获取失败'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  db.close()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>也很简单方便</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">HuangStomach</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">12</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/HuangStomach" target="_blank" title="GitHub" rel="external nofollow"><i class="fa fa-fw fa-github"></i></a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:bendanqusi@gmail.com" target="_blank" title="E-Mail" rel="external nofollow"><i class="fa fa-fw fa-envelope"></i></a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.facebook.com/profile.php?id=100012662087547" target="_blank" title="FB Page" rel="external nofollow"><i class="fa fa-fw fa-facebook"></i></a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.instagram.com/jipeng.h" target="_blank" title="Instagram" rel="external nofollow"><i class="fa fa-fw fa-instagram"></i></a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">HuangStomach</span>

  

  
</div>


  



  <div class="powered-by">由 <a class="theme-link" target="_blank" rel="external nofollow" href="https://hexo.io">Hexo</a> 强力驱动 v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" rel="external nofollow" href="https://github.com/theme-next/hexo-theme-next">NexT.Gemini</a> v6.3.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.3.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



	





  





  






<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    
      <style>
        a.gitment-editor-footer-tip { display: none; }
        .gitment-container.gitment-footer-container { display: none; }
      </style>
    

    






  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  
  

  

  

  

  

  

</body>
</html>
