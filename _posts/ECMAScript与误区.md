---
title: ECMAScript与误区
date: 2018-11-02 22:56:21
tags:
- JavaScript
categories:
- JavaScript
---

> 最近在和一些年轻的js开发者的交流中，发现大家对于一些ECMAScript标准仍然有一些误区

## const

在一些网络文章中，经常可以看到对于`const`的一些描述，大多数都是说明: *一旦声明则不可进行修改的常量*

我就经常会用这个来分辨一些只是浅尝辄止的开发者，也是我面试中的一个非常小的问题:

*当我声明了一个常量数组后，我还可以向内推送元素么？*

可惜很大一部分的同学都会回答我不能，因为声明了就不能改变。实际上，这里不能改变的不是值，而是指向的内存地址。

## 箭头函数

往往一些简单的特性所隐藏的功能则经常带来一些问题，我认识的一些开发者极其热衷于使用箭头函数，哪怕是在第三方的库中。

他们简单的认为箭头函数仅仅是简写了`function`关键字，然而当他们在一些内部函数或回调函数中尝试使用箭头函数的时候却发现，再也取不到相应`this`了。

## Promise

在`Proimse`普及之前，我们的代码经常是这样的:

``` javascript
a.do('sth', ra => {
    b.do('sth', rb => {
        c.do('sth', rc => {
            ...
        })
    })
})
```

拜异步特性所赐，我们的代码经常写的像锥子。

这时候`Promise`横空出世，然而周围的开发者90%居然会这么写:

``` javascript
a.then(ra => {
    b.then(rb => {
        c.then(rc => {
            ...
        })
    })
})
```

说实话，写的时候就没有疑问这和之前有什么区别么？

``` javascript
a
.then(ra => b)
.then(rb => c)
.then(rc => { ... })
```

解决回调嵌套地狱，才是`Promise`褒受欢迎的原因之一。

## async

曾经有个同事向我强力推荐`koa`, 当时公司内部用`express`比较多，我就问他，为什么要用`koa`呢？

回答居然是`koa`能用`async`……

`async`并不是一个指向性那么强的特性，实际上很多地方都能简单的用到，比如`express`:

``` javascript
app.get('*', async (req, res) => {
    // do sth
})
```

还有的朋友问过我，我都使用了这个特性了，为什么代码还是不像我想象中的运行呢？

实际上`async`只是一个语法糖，只是让你用同步代码的编写方式来**写**异步代码而已，`ES6`中其他大部分的特性同理。

## Class

`React`充分应用着`class`的特性，虽然我没有仔细阅读过源码去看具体的实现是否和`ES6`中的完全相符，我经常看到这样的代码:

``` javascript
class Component extend React.Component {
    constructor (props) {
        super(props)
    }
}
```

实际上哪怕你不声明，`class`也会隐式的生成并调用构造函数。

## 还是Class

这仍然是原型链的一种实现，不要想太多了。

## 结尾

我觉得最有用的特性现在看来还是尾递归优化……